import os
import pandas as pd
from scipy import stats
import seaborn as sns
import matplotlib.pyplot as plt
import itertools

from lib.variable_names import Variables
from lib.helpers import ExtractData, DataRoot

"""
This module performs analyzing process for regression data.
More details can be found in the documentation of each class below.

To execute a specific class to see how the output is generated:
    + please scroll down to the end of the script where the clause
      if __name__ == "__main__" is placed
    + assign a string to the 'mode' variable in function clean_data_run()
    + choices of the 'mode' variable are defined in function clean_data_run()
"""


class AnalyseData(DataRoot):
    """
    This class provides different methods for analyzing regression data
    """
    def __init__(self):
        super().__init__()
        self.regression_data_dict = ExtractData().extract_regression_data()

    def control(self):

        # get descriptive statistics of all datasets
        descriptive_stat = self.descriptive_stat()

        # get correlation matrix of each dataset of hypothesis 1
        corr_h1_refinitiv = self.corr_h1(data_set='refinitiv')
        corr_h1_spglobal = self.corr_h1(data_set='spglobal')
        corr_h1_sustainalytics = self.corr_h1(data_set='sustainalytics')

        # get correlation matrix of hypothesis 2
        corr_h2 = self.corr_h2(data=self.regression_data_dict['h2_main'])

        # export all generated data to Excel
        with pd.ExcelWriter(os.path.join(self.cleaned_data_root, Variables.DescriptiveStats.FILE_NAME)) as writer:
            descriptive_stat.to_excel(writer, sheet_name=Variables.DescriptiveStats.DESCRIPTIVE_STATS_SHEET_NAME, index=False)
            corr_h1_refinitiv.to_excel(writer, sheet_name=Variables.DescriptiveStats.CORR_H1_REFINITIV_SHEET_NAME, index=False)
            corr_h1_spglobal.to_excel(writer, sheet_name=Variables.DescriptiveStats.CORR_H1_SPGLOBAL_SHEET_NAME, index=False)
            corr_h1_sustainalytics.to_excel(writer, sheet_name=Variables.DescriptiveStats.CORR_H1_SUSTAINALYTICS_SHEET_NAME, index=False)
            corr_h2.to_excel(writer, sheet_name=Variables.DescriptiveStats.CORR_H2_SHEET_NAME, index=False)


    def descriptive_stat(self):
        """
        Returns a dataframe of descriptive statistics for each regression dataset
        that is retrieved and stored in the class variable 'regression_data_dict'.

        The data is used for Table 4 in the thesis.
        """
        result = pd.DataFrame()
        for key in self.regression_data_dict.keys():
            stat = self.regression_data_dict[key].describe().T
            stat['skewness'] = self.regression_data_dict[key].skew(axis=0)
            stat['kurtosis'] = self.regression_data_dict[key].kurtosis(axis=0)
            stat['hypothesis'] = key
            result = result.append(stat, ignore_index=False)
        result = result.reset_index()

        return result

    def corr_h1(self, data_set='refinitiv'):
        """
        :parameter data_set: str (choices are 'refinitiv', 'spglobal', and 'sustainalytics')

        This function generates Pearson pairwise correlation coefficients and p-values
        for all variables used in each dataset of the regression of hypothesis 1:
            - pairwise combinations are generated by using itertools package
            - scipy library is used to calculate Pearson pairwise correlation and two-sided p-values,
              for more info regarding the library:
              https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html

        The generated data is used to report table 5 in the thesis.

        :return result: a data frame contains all generated information
        """

        # get dataset to be used:
        if data_set == 'refinitiv':
            data = self.regression_data_dict['h1_refinitiv']
        elif data_set == 'spglobal':
            data = self.regression_data_dict['h1_spglobal']
        else:  # i.e data_set == 'sustainalytics'
            data = self.regression_data_dict['h1_sustainalytics']

        # get all variables' names used in regression of hypothesis 1
        all_var = [
            Variables.RegressionData.DependentVar.H1_CREDIT_RTG,
            Variables.RegressionData.IndependentVar.H1_ESG_RTG,
            Variables.RegressionData.IndependentVar.H1_ESG_ENV,
            Variables.RegressionData.IndependentVar.H1_ESG_SOC,
            Variables.RegressionData.IndependentVar.H1_ESG_GOV,
            Variables.RegressionData.ControlVar.H1_SIZE,
            Variables.RegressionData.ControlVar.H1_LEV,
            Variables.RegressionData.ControlVar.H1_ICOV,
            Variables.RegressionData.ControlVar.H1_OMAR
        ]

        # create all subsets of all_var with exactly 2 elements
        all_var_subset = set(itertools.combinations(all_var, 2))

        # calculate correlation coefficients and p-values of each subset
        result = []
        for _, element in enumerate(all_var_subset):
            data_dict = {
                'variable1': element[0],
                'variable2': element[1],
                'corr_coeff': stats.pearsonr(data[element[0]], data[element[1]])[0],
                'p_value': stats.pearsonr(data[element[0]], data[element[1]])[1],
                'dataset': data_set,
            }
            df_summary = pd.DataFrame.from_dict([data_dict])
            result.append(df_summary)
        result = pd.concat(result)
        result = result.reset_index(drop=True)

        return result


    @staticmethod
    def corr_h2(data):
        """
        :parameter data: a dataframe of regression data for hypothesis 2, extracted from 'regression_data.xlsx'

        This function generates pairwise correlation coefficients and p-values.
            - scipy library is used to calculate Pearson pairwise correlation and two-sided p-values,
            for more info regarding the library:
            https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html
            - the first printed out element of the tuple is the coefficient, and the second element is the p-value.

        Note: the pairwise correlation is calculated one by one, therefore it is important to look at the console
        to see the results.
        """

        # get all variables' names used in regression of hypothesis 1
        all_var = [
            Variables.RegressionData.DependentVar.H2_CREDIT_RTG_CHANGE,
            Variables.RegressionData.IndependentVar.H2_ESG_RATED_DUMMY,
            Variables.RegressionData.ControlVar.H2_AVG_SIZE,
            Variables.RegressionData.ControlVar.H2_AVG_LEV,
            Variables.RegressionData.ControlVar.H2_AVG_ICOV,
            Variables.RegressionData.ControlVar.H2_AVG_OMAR,
            Variables.RegressionData.ControlVar.H2_LONG_TERM_DUMMY,
        ]

        # create all subsets of all_var with exactly 2 elements
        all_var_subset = set(itertools.combinations(all_var, 2))

        # calculate correlation coefficients and p-values of each subset
        result = []
        for _, element in enumerate(all_var_subset):
            data_dict = {
                'variable1': element[0],
                'variable2': element[1],
                'corr_coeff': stats.pearsonr(data[element[0]], data[element[1]])[0],
                'p_value': stats.pearsonr(data[element[0]], data[element[1]])[1],
            }
            df_summary = pd.DataFrame.from_dict([data_dict])
            result.append(df_summary)
        result = pd.concat(result)
        result = result.reset_index(drop=True)

        return result

        print(stats.pearsonr(data['ESG_RATED'], data['CREDIT_RTG_CHANGE']))
        print(stats.pearsonr(data['ESG_RATED'], data[Variables.ControlVar.H1_LEV]))
        print(stats.pearsonr(data['ESG_RATED'], data[Variables.ControlVar.H1_SIZE]))
        print(stats.pearsonr(data['ESG_RATED'], data[Variables.ControlVar.H1_ICOV]))
        print(stats.pearsonr(data['ESG_RATED'], data[Variables.ControlVar.H1_OMAR]))

        print(stats.pearsonr(data['CREDIT_RTG_CHANGE'], data[Variables.ControlVar.H1_LEV]))
        print(stats.pearsonr(data['CREDIT_RTG_CHANGE'], data[Variables.ControlVar.H1_SIZE]))
        print(stats.pearsonr(data['CREDIT_RTG_CHANGE'], data[Variables.ControlVar.H1_ICOV]))
        print(stats.pearsonr(data['CREDIT_RTG_CHANGE'], data[Variables.ControlVar.H1_OMAR]))

        print(stats.pearsonr(data[Variables.ControlVar.H1_LEV], data[Variables.ControlVar.H1_SIZE]))
        print(stats.pearsonr(data[Variables.ControlVar.H1_LEV], data[Variables.ControlVar.H1_ICOV]))
        print(stats.pearsonr(data[Variables.ControlVar.H1_LEV], data[Variables.ControlVar.H1_OMAR]))

        print(stats.pearsonr(data[Variables.ControlVar.H1_SIZE], data[Variables.ControlVar.H1_ICOV]))
        print(stats.pearsonr(data[Variables.ControlVar.H1_SIZE], data[Variables.ControlVar.H1_OMAR]))

        print(stats.pearsonr(data[Variables.ControlVar.H1_ICOV], data[Variables.ControlVar.H1_OMAR]))



    @staticmethod
    def pairplot(data):
        """
        :parameter data: a dataframe of regression data, extracted from 'regression_data.xlsx'

        Plotting histogram and scatter plots of regression variables using seaborn package.
        For more information: https://seaborn.pydata.org/generated/seaborn.pairplot.html

        The generated data is used in Appendix A of the thesis.
        """
        plt.figure(figsize=(20, 20))
        sns.pairplot(data,
                     vars=[
                         # 'year',
                         Variables.RegressionData.H1_ESG_RTG_VAR,
                         Variables.RegressionData.H1_CREDIT_RTG_VAR,
                         Variables.ControlVar.H1_SIZE,
                         Variables.ControlVar.H1_LEV,
                         Variables.ControlVar.H1_ICOV,
                         Variables.ControlVar.H1_OMAR
                     ],
                     # hue='INDUSTRY',
                     corner=True,
                     height=2,
                     aspect=1
                     )
        plt.show()


if __name__ == "__main__":
    AnalyseData().control()
    # AnalyseData().corr(data=AnalyseData().regression_data_dict['h1_refinitiv'])
    pass
